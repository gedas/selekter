// Generated by dts-bundle v0.7.3

export interface AreaOptions {
        /**
            * CSS selector that specifies an element in a subtree of root element that
            * can be selected.
            *
            * @default `.selekter-selectable`
            */
        selectable: string;
        /**
            * A style class to be added to area root element when there are elements
            * selected.
            *
            * @default `selekter-selection`
            */
        selectionClass: string;
        /**
            * A style class to be added to selected element.
            *
            * @default `selekter-selected`
            */
        selectedClass: string;
}
/**
    * A factory function returning an array of default selectors.
    * Intended to be used when specifying selectors for new `Area`.
    */
export const createDefaultSelectors: () => (MouseSelector | RectSelector)[];
/**
    * Represents an area containing selectable elements.
    */
export class Area {
        root: HTMLElement;
        options: Partial<AreaOptions>;
        /**
            * Creates an `Area`.
    
            * @param root The root element.
            * @param options The area options.
            * @param selectors Selectors to be registered for this area. SubsequentG
            *   selectors will override preceding selectors of the same type and won't
            *   be added more than once. Use this parameter to change the configuration
            *   of default selectors or add new ones.
            *   ~~~
            *   [
            *     ...createDefaultSelectors(),
            *     new RectSelector({ threshold: 20 }) // override default
            *   ]
            *   ~~~
            */
        constructor(root: HTMLElement, options?: Partial<AreaOptions>, selectors?: (MouseSelector | RectSelector)[]);
        /**
            * Returns the current selection.
            *
            * Modifying this selection will result in selection change events being
            * dispatched. If `MutationObserver` is supported, then selection is updated
            * only when `root` subtree changes. The update includes removing from
            * selection elements that are no longer in `root` subtree.
            */
        getSelection(): Selection;
        /**
            * Sets current selection.
            *
            * Selection change events will be dispatched for each selectable that is not present
            * in the new selection.
            *
            * @param selection New selection.
            */
        setSelection(selection: Selection): void;
        /**
            * Returns a set of selectable elements queried by `selectable` option.
            * If `MutationObserver` is supported, then set is recreated only when `root`
            * subtree changes.
            */
        getSelectables(): Set<Element>;
        /**
            * Destroys the area by disconnecting all connected selectors.
            * No option to recover other than creating new `Area`.
            */
        destroy(): void;
}

import './selekter.css';

export interface MouseSelectorOptions {
        /**
            * CSS selector that specifies an element that when clicked will select
            * the closest selectable parent.
            *
            * @default `.selekter-tick`
            */
        tick: string;
}
/**
    * A selector that makes it possible to select elements with mouse right click.
    *
    * If selection is empty, then the first element can be selected only with
    * a tick. Otherwise, elements are selectable by clicking them directly.
    */
export class MouseSelector implements Selector {
        constructor(options?: Partial<MouseSelectorOptions>);
        connect(area: Area): Destroy;
}

/**
    * An alias for object having left and right coordinates, width and height.
    * For example, other `Rect` object or
    * [`DOMRect`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).
    */
export type RectLike = {
        left: number;
        top: number;
        width: number;
        height: number;
};
/**
    * Represents a mutable rectangular boundary.
    */
export class Rect {
        left: number;
        top: number;
        width: number;
        height: number;
        /**
            * Creates a new rectangle with specified coordinates and size.
            *
            * @param left The X coordinate of the left side of the rectangle.
            * @param top  The Y coordinate of the top of the rectangle.
            * @param width The width of the rectangle.
            * @param height The height of the rectangle.
            */
        constructor(left?: number, top?: number, width?: number, height?: number);
        /**
            * Creates a rectangle from existing rect-like object.
            *
            * @param r Other rect-like object to create rectangle from.
            * @example `Rect.from(element.getBoundingClientRect())`
            */
        static from(r: RectLike): Rect;
        /**
            * Determines whether this rectangle intersects other rect-like object.
            *
            * @param r The specified rect-like object.
            */
        intersects(r: RectLike): boolean;
}

export interface RectSelectorOptions {
        /**
            * A style class to be added to lasso element.
            *
            * @default `selekter-lasso`
            */
        lassoClass: string;
        /**
            * The minimum length of lasso edge in pixels for lasso to be visible.
            *
            * @default `10`
            */
        threshold: number;
        /**
            * The element to append lasso to. If not specified, then lasso will be
            * appended to area `root` element.
            */
        appendTo: Element;
        /**
            * Returns rectangular boundary of the selectable element. Invoked for each
            * selectable element in order to test whether element intersects the lasso.
            *
            * Defaults to `element.getBoundingClientRect()`.
            *
            * @param element The selectable element.
            */
        boundary(element: Element): RectLike;
}
/**
    * A selector that makes it possible to select elements while pressing and
    * moving the mouse creating a region. This rectangular region is known as
    * lasso. The elements whose boundaries intersect with the lasso will be
    * selected.
    */
export class RectSelector extends Rect implements Selector {
        constructor(options?: Partial<RectSelectorOptions>);
        connect(area: Area): Destroy;
}

/**
    * The type of selection change event.
    */
export const SELECTION_EVENT = "selection";
/**
    * Represents a selection change event published when element has been selected
    * or deselected.
    */
export interface SelectionEvent extends CustomEvent {
        readonly target: Element;
        readonly detail: {
                selected: boolean;
        };
}
/**
    * Stores unique selected elements. Publishes selection event for each element
    * being added or removed, i.e, when selection size changes.
    */
export class Selection {
        /**
            * Creates new `Selection`.
            *
            * @param elements Elements to be added to the new `Selection`.
            */
        constructor(elements?: Element[]);
        /**
            * Returns the number of selected elements.
            */
        readonly size: number;
        /**
            * Returns a new `Iterator` object that contains selected elements.
            */
        values(): IterableIterator<Element>;
        /**
            * Appends a new element.
            *
            * @param element The element to be added.
            * @returns This `Selection` object.
            */
        add(element: Element): this;
        /**
            * Removes the `element`.
            *
            * @param element The element to be removed.
            * @return The value that `has(element)` would have previously returned.
            */
        delete(element: Element): boolean;
        /**
            * Determines whether an `element` is selected.
            *
            * @param element The element to test for selection.
            */
        has(element: Element): boolean;
        /**
            * Removes all elements.
            */
        clear(): void;
        /**
            * Toggles selection state of the `element`.
            *
            * If `element` is selected then removes it and returns `false`, if not,
            * then adds it and returns `true`.
            *
            * The selection state of the `element` can be forced using `force` argument.
            * If `force` is true, adds the element, otherwise - removes.
            *
            * @param element The element which selection state should be toggled.
            * @param force Determines whether `element` should be selected or not.
            */
        toggle(element: Element, force?: boolean): boolean;
        /**
            * Sets this selection to the intersection with `other` set or selection.
            * This selection will contain elements present in both collections.
            *
            * @param other The set or selection being intersected with this selection.
            */
        intersect(other: Set<Element> | Selection): this;
}

/**
    * An alias for a function that destroys the selector.
    */
export type Destroy = () => void;
/**
    * Provides the way of selecting elements within the area.
    */
export interface Selector {
        /**
            * Registers this selector on the specified `area`.
            *
            * Performs any initialization logic required by the selector, e.g. adds
            * respective event listeners. Changes can be revoked through returned
            * function.
            *
            * @param area The area to register this selector to.
            * @returns A function that destroys registered selector.
            */
        connect(area: Area): Destroy;
}

